인터넷은 연결망
웹은 연결된 사람끼리 서로 정보를 공유할 수 있는 공간
웹 서버는 클라이언트의 요청을 들어주는 곳

프레임워크는 기능, 클래스, 인터페이스 모음 --> 툴킷
런타임은 실행 환경, 실행기 --> 계산기

node.js는 웹 브라우저에 내장된 자바스크립트 엔진 대신 내 컴퓨터가 자바스크립트 코드를 실행할 수 있게 한다 --> 자바스크립트로 작성한 서버의 기능들을 돌리기 위해 브라우저를 꼭 사용할 필요가 없어짐

노드 사용목적: 자바스크립트로 실시간 + 사용자 맞춤 서비스 제공

노드는 논 블로킹 비동기 방식
논 블로킹: 이전 작업의 완료 여부와 관계 없이 다른 작업을 수행함
블로킹: 이전 작업이 완료될 때 까지 다른 작업은 대기함
비동기: 이전 작업이 끝나는 것을 기다리지 않고 바로 실행
동기: 작업을 순차적으로 실행함 --> 끝나는 것을 기다림

블로킹 비동기 --> 일을 한번에 벌림 + 대신 어떤 작업이 완료되야 다른 작업 수행 ex. 은행 번호표는 여러 기기가 받고 업무는 번호순으로 받음

논 블로킹 동기 --> ?

논 블로킹 비동기 --> 주방일 --> 카운터 + 키오스크에서 주문 막 들어옴 --> 한번에 여러 화구에서 조리 --> 서빙

노드는 싱글 스레드, 이벤트 루프 기반

스레드 할당 --> 스레드 완료 --> 콜백 큐에서 대기 --> 이벤트 루프가 스택이 비었음을 감지 + 큐에 작업 결과 있음 --> 스택으로 push --> 각 완료된 작업들이 콜백 함수 실행 가능한지 요청 --> 수락하면 완료된 작업들이 콜백 함수 실행 --> 작업 실행 결과를 갖고 위치로 복귀

이해도 측정
1. 웹 서버란 클라이언트의 요청을 받아 처리하고 적절한 응답을 보내주는 프로그램이다.
2. 노드는 자바스크립트 런타임이다.
3. 노드는 논블로킹 비동기 방식이다.
4. 경량화된 프로세스를 스레드라고 한다.
5. 노드는 싱글 스레드 기반이다.
6. 노드가 싱글 스레드이지만 논블로킹 비동기 방식을 택할 수 있는 이유는 이벤트 루프 때문이다.
7. 노드는 비동기 처리를 할 때 응답을 기다리는 대신 작업이 종료되면 이벤트를 발생시키고 콜백 큐에 작업을 등록하는 방식을 택했다.
8. 이벤트 루프는 지속적으로 콜 스택이 비었는지 확인한다.
9. 작업이 끝나면 실행하는 함수를 콜백 함수라고 한다.
10. 노드의 API와 개발도구를 이용하기 위해서는 NPM을 이용해야 한다.





변수 호이스팅: 변수의 선언과 초기화가 동시에 이루어져, 아직 값이 없음에도 오류가 나지 않는 현상

var 선언: 선언과 동시에 undefined로 초기화 --> 값은 없지만 메모리를 차지함 --> 변수를 할당하지 않았음에도 마음대로 참조가 가능해짐 --> 호이스팅 문제 --> let, const 사용

자바스크립트 데이터 타입: 숫자, 문자, 불리언, undefined, null

function level scope: 함수 블록 내에서 선언한 변수는 함수 내에서만 인정하고 함수 외부에서 선언한 변수는 모두 전역변수 --> var --> 원하지 않는 값을 덮어쓸 수 있음

let, const는 block level scope

let은 가변 + 선언과 동시에 초기화하지 않으면 undefined, const는 불변 + 선언과 초기화를 같이 해주도록

클로저: 내부 함수가 외부 함수의 스코프에 접근할 수 있는 것
자바스크립트에서 스코프는 함수 단위로 생성

자바스크립트의 객체: 키 값의 쌍으로 이루어진 프로퍼티의 정렬되지 않은 집합
프로퍼티: 키-값 쌍으로 이루어진, 객체가 가진 특징 --> 멤버 (자바로 따지면 필드, 메소드 모두 포함), 함수 프로퍼티는 메소드

배열.push: 배열 요소 추가

구조 분해 할당: 객체나 배열을 분해하는 방법. 배열의 경우 첫번째 원소부터 사용

자바스크립트의 this는 호출하는 방법에 의해 결정
ex.
객체가 console.log(this)를 실행하는 메소드 실행 --> 자기 프로퍼티 출력
전역에서 this 출력 --> 전역 == 윈도우 객체 출력

this를 객체로 고정하고 싶다면 bind 사용. 단, 람다식은 내부 스코프에this가 없어서 상위 함수의 this/전역 객체의 this를 불러옴 (bind 사용 불가)
--> this를 people 객체로 하고 싶다면 people.say.bind(people);

